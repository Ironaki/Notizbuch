* EPFL Scala
** Functional Programming Principle in Scala
*** Week 1
**** Lecture 1.1 Programming Paradigms
***** Imperative Programming 
+ modify mutable variables
+ using assignment
+ control flow: e.g. if-else, loop
***** Function Programming
+ restricted sense: no mutable variable/assignment/control structure
+ wider sense: focus on functions
**** Lecture 1.2 Elements of Programming
***** Substitution model
+ reduce an expression to a value
+ works on expression that does not have side effect
+ does not always terminate
****** Evaluation Strategy
+ call-by-name
+ call-by-value
**** Lecture 1.3 Evaluation Strategies and Termination
+ call-by-value terminates -> call-by-name terminates (BUT the other direction is not true)
+ Scala normally use call-by-value, but can force to use call-by-name
#+BEGIN_SRC scala
def constOne(x: Int, y: => Int) = 1 // 2nd arg is call-by-name
constOne(1+2, loop) // This is OK
constOne(loop, 1+2) // infinite loop
#+END_SRC
**** Lecture 1.4 Conditionals and Value Definitions
+ if-else as an expression
+ boolean as predicate
***** Value Definitions
+ /def/: by-name
+ /val/: by-value
#+BEGIN_SRC scala
def loop: Boolean = loop
val x = loop // infinite loop
def x = loop // This is ok
#+END_SRC
**** Lecture 1.5 Example: square roots with Newton's method
+ Example: Problems for floating point numbers
**** Lecture 1.6 Blocks and Lexical Scope
***** block and visibility
+ def inside block only visible inside
+ def outside block visible inside as long as it's not shadowed
***** Continued Expression
#+BEGIN_SRC scala
// semicoloms usually omitted
// two expressions
a
+b
// one expression
(a
+b)
// one expression
a+
b
#+END_SRC
**** Lecture 1.7 Tail Recursion
+ Tail recursion is the functional form of a loop3
*** Week 2
**** Lecture 2.1 Higher-Order Functions
+ Function Type
  e.g. f: Int => Interface
+ Anonymous Functions
  They are just syntactic sugar
#+BEGIN_SRC scala
(x: Int) = x * x 
//anoymous function above is syntactic sugar of the two lines below
def square(x: Int) = x * x
square 
#+END_SRC
**** Lecture 2.2 Currying
+ Scala syntax for currying
#+BEGIN_SRC scala
def cube(x) = x * x * x
def sum(f: Int => Int)(a: Int, b: Int): Int
// So you can use the following
sum(cube)
// Type of sum:
// (Int => Int) => (Int, Int) => Int
// or
// (Int => Int) => ((Int, Int) => Int)
#+END_SRC
**** Lecture 2.3 Example: Finding Fixed Points
**** Lecture 2.4 Scala Syntax Summary
Symbols:
- |      alternative
- [...]  option
- {...}  reptition
**** Lecture 2.5 Functions and Data
Just OOP
**** Lecture 2.6 More Fun with Rationals
***** Data Abstraction
#+BEGIN_SRC scala
// calculate gcd at first
class Rational(x: Int, y: Int) {
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)
  private val g = gcd(x, y)
  def numer = x/g
  def denom = y/g
}

// calculate gcd when number and denom called
class Rational(x: Int, y: Int) {
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)
  def numer = x/gcd(x, y)
  def denom = y/gcd(x, y)
}

// calculate gcd at first in numer and denom definition
class Rational(x: Int, y: Int) {
  private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a%b)
  val numer = x/gcd(x, y)
  val denom = y/gcd(x, y)
}
#+END_SRC
In all three cases, users will observe the same behavior of Rational
***** (^•ω •^)
- require: enforce a precondition
- assert: check the code itself
**** Lecture 2.7 Evaluation and Operators
***** Substitution model also works for class and method
***** In Scala, you can use symbols as identifiers (thus function names)...
#+BEGIN_SRC scala
def + (a: Int, b: Int) = a+b
#+END_SRC
The precedence of an operator is determined by its first character

